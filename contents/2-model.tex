\section{Разработка модели} \label{sec:timing}

\subsection{Модель атаки по времени}

При атаке по времени атакующий измеряет время, которое уходит у алгоритма на
обработку запросов. Атакующий может делать это, либо пассивно наблюдая за
обращениями легитимных пользователей, либо самостоятельно делая запросы к
криптосистеме.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{timing-attack-msc.png}
    \caption{Пример атаки по времени}
\end{figure} \label{fig:msc}

На рисунке \ref{fig:msc} представлена схема примера взаимодействия
атакующего (Ева) и криптосистемы (Алиса). Физически они могут быть представлены
двумя процессами на одной системе, разными узлами в компьютерной сети и т.д.
Ева формирует запрос к Алисе и отправляет его, сохраняя перед этим текущее
время $T_1$. Между моментом времени, который сохранила Ева, и моментом, когда
запрос будет передан, есть некоторая задержка. Эта задержка может быть вызвана
обработкой запроса сетевым стеком на компьютерах Евы и Алисы или накладными
расходами на совершение системных вызовов к операционной системе.

Этот запрос принимается Алисой также с некоторой задержкой. После чего Алиса
обрабатывает его, начав в момент $T_2$ и закончив в момент $T_3$. Алиса
формирует ответ и отправляет его обратно Еве. Отправка и получение ответа так
же, как и запроса, сопровождаются задержками. Как только Ева получает ответ, она
запоминает текущее время $T_4$.

Еву интересует реальное время затраченное на шифрование, если обозначить его как
$X$, то $X = T_3 - T_2$.

Измеренное ей значение $Z$ представляет собой сумму искомой величины и шума
$Y = (T_2 - T_1) + (T_4 - T_3)$:

\begin{equation}
Z = X + Y = (T_3 - T_2) + (T_2 - T_1) + (T_4 - T_3) = T_4 - T_1
\end{equation} \label{eq:noise}

При атаке по времени на программу валидации пароля, атакующий обращается к
ней, поочерёдно передавая в качестве пароля все возможные строки из одного
символа. Та строка, которая совпадёт на один символ с паролем, потребует от
проверяющей программы выполнить на одну операцию сравнения больше, чем остальные
строки. Благодаря этому, на её проверку должно уйти больше времени. В качестве
догадки о том, каким был первый символ строки, атакующий примет ту строку,
обработка которой длилась дольше остальных. После чего, он повторит описанную
процедуру для того, чтобы узнать второй символ строки и все следующие за ним.

Так как доступная для измерения атакующим задержка ($Z$ в уравнении
\ref{eq:noise}) содержит шум, ему потребуется повторить каждое измерение
несколько раз.

Если атакующий уже сумел получить $n$ первых символов пароля. После этого
он снял по $m$ измерений времени обработки строк, полученных добавлением к
известным ему $n$ символам всех возможных вариантов следующего символа $s_1,
s_2, ... s_k$. Если обозначить как $Z_i = \{ z_i^{(1)}, z_i^{(2)} ... z_i^{(m)}
\}$ множество измерений времени обработки строки, полученной добавлением к
известным $n$ символам символа $s_i$, то задачей атакующего будет ответ на
вопрос о том, для какого $i$ математическое ожидание распределения, из которого
были получены $Z_i$ наибольшее.

Для ответа на данный вопрос, существует несколько общепринятых методов. Они
описаны в работе \cite{anmodel}. Первый и самый наивный способ состоит в
нахождении среднего значения времени обработки каждого для каждого предполагаемого
значения неизвестного символа:

\begin{equation}
\bar{Z_i} = \frac{1}{m} \sum_{j=1}^m Z_i^{(j)}
\end{equation} \label{eq:pointest}

После чего в качестве значения неизвестного символа выбирается такой $s_i$, для
которого значение $\bar{Z_i}$ из уравнения \ref{eq:pointest} наибольшее. Легко
понять, что полученные таким образом значения представляют собой точечные оценки
математического ожидания. Недостаток данного метода состоит в том, что точечные
оценки могут быть неточны и не продоставляют никакой возможности оценить их
точность.

Очевидным улучшением метода точечных оценок является вычисление доверительных
интервалов для математического ожидания. Этот метод описан в работе
\cite{confint} и основывается на центральной предельной теореме, которая для
случая описанных выше задержек формулируется следующим образом (при $n \to \inf$):

\begin{equation}
\bar{Z_i} - \mu_i \to N(0, \frac{\sigma}{\sqrt{n}})
\end{equation} \label{eq:clt}

Здесь символом $\mu_i$ обозначено математическое ожидание распределения,
из которого были получены измерения атакующего, а $\sigma$ обозначает
среднеквадратичное отклонение этого распределения. Другими словами, при
достаточно больших $n$ разность среднего значения задержки, измеренной
атакующим, имеет нормальное распределение с математическим ожиданием $0$ и
среднеквадратичным отклонением $\frac{\sigma}{\sqrt{n}}$.

Конечная формула для доверительного интервала выглядит следующим образом:

\begin{equation}
(\bar{Z_i} - t^{\star}(\alpha) \frac{s}{\sqrt{n}}, \bar{Z_i} + t^{\star}(\alpha) \frac{s}{\sqrt{n}})
\end{equation} \label{eq:confint}

Здесь символом $s$ обозначена точечная оценка среднеквадратичного отклонения
измеряемой задержки, а $t^{\star}$ -- критическое значение, которое вычисляется
по t-распределению Стьюдента для требуемого уровня надёжности $\alpha$.

Имея в распоряжении доверительные интервалы для математических ожианий,
атакующий способен оценивать точность своего предположение о значении
неизвестного ему символа. Как видно из уравнения \ref{eq:confint}, ширина
доверительного интервала обратно пропорциональна корню числа измерений,
поэтому атакующий может улучшать точность своих оценок, увеличивая число
измерений.

\subsection{Программа валидации пароля}

В этой главе описана разработка модели программы валидации пароля, которая будет
использована для оценки того, насколько точной может быть атака по времени на
такую программу.

Было решено реализовать модель программы валидации пароля на языке Си, так
как он позволяет очень точно контроллировать работу программы на низком
уровне, не требуя в большинстве случаев прибегать к использованию языка
ассемблера. В силу того, что язык Си компилируется в машинный код и не требует
для выполнения никакой виртуальной машины, написанные на нём программы
существенно производительнее программ, написанных на других популярных языках
программирования, таких как Lisp, Haskell, Perl или Python.

Реальная программа валидации пароля принимает от пользователя на вход строку,
которую она сравнивает с секретной строкой, хранящейся в недоступном для
пользователя месте. Взаимодействие с пользователем может происходить через
TCP, UDP или UNIX сокет, через терминал или через графический интерфейс.
Пароль, с которым сравнивается пользовательский ввод, может храниться в файле,
доступ к которому имеет только программа валидации пароля или на удалённом
сервере. Несмотря на существование более надёжных чем пароль методов авторзации
(публичные ключи, биометрические данные и др.), он по прежнему используется
многими программами. В реальности такие решения обычно хранят хеш-сумму пароля и
при помощи неё валидируют предоставленный пользователем пароль, но в данной работе
будет рассмотрен лишь вариант, когда пароль хранится в открытом виде.

Модель программы валидации пароля не имеет графического интерфейса и запускается
из командной строки, принимая в качестве единственного аргумента строку, которую
она сравнивает со статической константной строкой-паролем, которая хранится в
её памяти. Было решено сохранить строку-пароль статически в исполняемом файле
программы валидации пароля для уменьшения накладных расходов, которые возникли
бы, если бы программа была вынуждена читать эту строку из внешнего источника,
такого как файл, терминал или сокет. С той же целью в качестве способа ввода
пароля пользователем был выбран аргумент командной строки. Так как данная модель
представляет упрощённый вариант программы валидации пароля, в случае атаки на
реальную программу валидации пароля, шум, присутствующий в измерениях атакующего
будет сильнее и эффективность атаки ухудшится. Учитывая сказанное выше,
оценки эффективности атаки по времени, полученные на разработанной в данной
работе модели, могут рассматриваться как верхние оценки для эффективности атаки
на реальную прогамму.

При такой модели, атакующий имеет возможность многократно запускать
программу-модель, передавая ей в качестве аргумента выбранные им строки, и
измеряя время выполнения её выполнения. Общепринятым методом запуска программы
и ожидания её завершения в Linux является последовательность системных вызовов
\texttt{vfork}, \texttt{execve}, \texttt{wait} \cite{kerrisk}. При этом
атакующий не способен измерять задежки между событиями соседнего процесса, в
котором выполняется модель уязвимой программы. Ему доступна лишь задержка между
моментом, когда он создал новый процесс при помощи \texttt{vfork}, и моментом,
когда он дождался его завершения при помощи \texttt{wait}.

Для более точного исследования характиристик задержки, которая уходит на
сравнение строк, было принято решение добавить в программу валидации пароля
возможность измерения времени, которое ушло непосредственно на вызов функции
сравнения строк. С той же целью была добавлена возможность совершить несколько
операций сравнения одних и тех же строк за один запуск программы валидации
пароля.

\subsection{Написание программы}

Для исследований того, насколько велик шум, который влияет на измеряемое атакующим значение,
описанное в уравнении \ref{eq:noise}, была написана программа \nameref{app:vuln}, которая сравнивает
передаваемую ей в качестве аргумента строку с внутренней строкой, состоящей из большого числа
символов \texttt{'a'}. Программа повторяет вызов функции сравнения в цикле заданное
пользователем число раз. Также эта программа измеряет время, которое было потрачено ею
на выполнение всего цикла сравнений и сообщает его пользователю. Это время будет являться
реальным времение обработки запроса, которо было обозначено как $X$ в уравнении \ref{eq:noise}.

На листинге \ref{src:vulnsnip} показана основная часть программы \nameref{app:vuln}:

\begin{lstlisting}[caption=Фрагмент программы \texttt{vulnerable.c}, label=src:vulnsnip]
int (*my_strcmp)(const char *s1, const char *s2) = strcmp;

char reference[] = "aaa...";

int main(int argc, char **argv)
{
	uint64_t begin, end;

	/* ... */

	begin = timestamp();
	for (int i = 0; i < n; ++i)
		my_strcmp(argv[1], reference);
	end = timestamp();

	printf("%lld\n", end - begin);
}
\end{lstlisting}

Для сравнения строк используется библиотечная функция \texttt{strcmp}. Вызовы к ней совершаются
через глобальный указатель \texttt{my\_strcmp}. Это было сделано для того, чтобы предотвратить оптимизации
компилятором вызовов к библиотечной функции \texttt{strcmp}, которые тот мог произвести так как программа
была собрана с флагом \texttt{-O3} для получения наиболее оптимального кода.

Время измерялось при помощи функции \texttt{timestamp}, представленной на листинге
\ref{src:timestamp}.

\begin{lstlisting}[caption=Функция \texttt{timestamp}, label=src:timestamp]
static inline uint64_t timestamp(void)
{
	uint32_t bottom;
	uint32_t top;
	asm volatile (
			"CPUID\n\t"
			"RDTSC\n\t"
			"mov %%edx, %0\n\t"
			"mov %%eax, %1\n\t": "=r" (top), "=r" (bottom)
#if __x86_64__
			:: "%rax", "%rbx", "%rcx", "%rdx");
#elif __i386__
			:: "%eax", "%ebx", "%ecx", "%edx");
#endif
	return (((uint64_t) top) << 32) | bottom;
}
\end{lstlisting}

Эта функция получает текущее время, обращаясь к счётчику тактов процессора при
помощи ассемблерной инструкции \texttt{rdtsc}, доступной на процессорах Intel x86.
Этот способ рекомендуется разработчиками Intel \cite{rdtsc} как наиболее точный для измерения
времени. Полученное при помощи этой инструкции значение представляет собой число
число тактов, прошедших с момента старта процессора, и может быть переведено в
секунды делением на тактовую частоту процессора. Так же, эта функция выполняет инструкцию
\texttt{cpuid} для того, чтобы предотвратить внеочердное выполнение
(англ. Out-of-order execution) процессором инструкций, которые следуют за \texttt{rdtsc}.

Для измерения времени, которое в соответствии c описанной в главе <<\nameref{sec:timing}>>
моделью, соответсвовало бы времени, которое способен измерить атакующий, была
была написана программа \nameref{app:timestamp}, эта программа вызывает программу
\nameref{app:vuln} и дожидается её завершения при помощи последовательности системных
вызовов \texttt{fork}, \texttt{execve} и \texttt{wait}. При этом, она передаёт
программе \nameref{app:vuln} указанные пользователем аргументы и измеряет время, которое
прошло между моментом, когда она создала новый процесс при помощи \texttt{fork},
и моментом, когда она узнала о его завершении через системный вызов \texttt{wait}.
Как и в программе \nameref{app:vuln}, время измеряется при помощи функции \texttt{timetamp},
представленной на листинге \ref{src:timestamp}.

Для снятия большого числа измерений времени программами \nameref{app:vuln} и
\nameref{app:timestamp}, был написал Perl-скрипт \nameref{app:collect}. Основная логика его
работы преставлена на листинге \ref{src:collectsnip};

\begin{lstlisting}[caption=Фрагмент скрипта \texttt{collect.pl}, label=src:collectsnip]
my ($cmd, $reps, $its, $maxlen) = @ARGV;

print "iterations,length,cycles\n";

for (my $i = 0; $i < $reps; ++$i) {
	print STDERR "\r         \r$i / $reps" if ($i \% 100 == 0);

	my $len = int(rand $maxlen);
	my $str = "a" x $len . "b" x ($maxlen - $len);
	my $cycles = `$cmd $str $its`;
	chomp($cycles);
	print "$its,$len,$cycles\n"
}
\end{lstlisting}

Этот скрипт измеряет время выполнения цикла вызовов \texttt{strcmp} либо при помощи
программы \nameref{app:vuln}, либо при помощи \nameref{app:timestamp}, указанное пользователем
число раз и выводит на поток стандартного вывода таблицу измерений в формате CSV.
Для каждого измерения скрипт генерирует строку, которая совпадает с в внутренней строкой 
\nameref{app:vuln} на некоторое количество символов, которое выбирается при помощи генератора
псевдослучайных чисел для каждого запуска.

\clearpage
