\section{Разработка модели} \label{sec:timing}

При атаке по времени атакующий измеряет время, которое уходит у алгоритма на
обработку запросов. Атакующий может делать это, либо пассивно наблюдая за
обращениями легитимных пользователей, либо самостоятельно делая запросы к
криптосистеме.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{timing-attack-msc.png}
    \caption{Пример атаки по времени}
\end{figure} \label{fig:msc}

Рассмотрим представленный на рисунке \ref{fig:msc} пример схемы взаимодействия
атакующего (Ева) и криптосистемы (Алиса). Физически они могут быть представлены
двумя процессами на одной системе, разными узлами в компьютерной сети и т.д.
Ева формирует запрос к Алисе и отправляет его, сохраняя перед этим текущее
время $T_1$. Между моментом времени, который сохранила Ева, и моментом, когда
запрос будет передан, есть некоторая задержка. Эта задержка может быть вызвана
обработкой запроса сетевым стеком на компьютерах Евы и Алисы или накладными
расходами на совершение системных вызовов к операционной системе.

Этот запрос принимается Алисой также с некоторой задержкой. После чего Алиса
обрабатывает его, начав в момент $T_2$ и закончив в момент $T_3$. Алиса
формирует ответ и отправляет его обратно Еве. Отправка и получение ответа так
же, как и запроса, сопровождаются задержками. Как только Ева получает ответ, она
запоминает текущее время $T_4$.

Еву интересует реальное время затраченное на шифрование, обозначим его как $X$ :

$X = T_3 - T_2$

Измеренное ей значение $Z$ представляет собой сумму искомой величины и шума
$Y = (T_2 - T_1) + (T_4 - T_3)$:

\begin{equation}
Z = X + Y = (T_3 - T_2) + (T_2 - T_1) + (T_4 - T_3) = T_4 - T_1
\end{equation} \label{eq:noise}

\subsection{На какие вопросы хочет отвечать Ева?}

При атаке по времени на программу верификации пароля, атакующий обращается к
ней, поочерёдно передавая в качестве пароля все возможные строки из одного
символа. Та строка, которая совпадёт на один символ с паролем, потребует от
проверяющей программы выполнить на одну операцию сравнения больше, чем остальные
строки. Благодаря этому, на её проверку должно уйти больше времени. В качестве
догадки о том, каким был первый символ строки, атакующий примет ту строку,
обработка которой длилась дольше остальных. После чего, он повторит описанную
процедуру для того, чтобы узнать второй символ строки и все следующие за ним.

Так как доступная для измерения атакующим задержка ($Z$ в уравнении
\ref{eq:noise}) содержит шум, ему потребуется повторить каждое измерение
несколько раз.

Допустим, что атакующий уже сумел получить $n$ первых символов пароля. После
этого он снял по $m$ измерений времени обработки строк, полученных добавлением
к известным ему $n$ символам всех возможных вариантов следующего символа. Если
обозначить как $Z_i = \{ z_i^{(1)}, z_i^{(2)} ... z_i^{(m)} \}$ множество
измерений времени обработки строки, полученной добавлением к известным $n$
символам символа $s_i$, то задачей атакующего будет ответ на вопрос о том,
для какого $i$ мат. ожидание распределения, из которого были получены $Z_i$
наибольшее.

Что за бред? Может быть просто накинуть текст про линейную регрессию?

\subsection{Какие используются методы для ответа на этот вопрос?}

\clearpage
