\section{Разработка модели} \label{sec:timing}

\subsection{Модель атаки по времени}

При атаке по времени атакующий измеряет время, которое уходит у алгоритма на
обработку запросов. Атакующий может делать это, либо пассивно наблюдая за
обращениями легитимных пользователей, либо самостоятельно делая запросы к
криптосистеме.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{timing-attack-msc.png}
    \caption{Пример атаки по времени}
\end{figure} \label{fig:msc}

На рисунке \ref{fig:msc} представлен схема примера взаимодействия
атакующего (Ева) и криптосистемы (Алиса). Физически они могут быть представлены
двумя процессами на одной системе, разными узлами в компьютерной сети и т.д.
Ева формирует запрос к Алисе и отправляет его, сохраняя перед этим текущее
время $T_1$. Между моментом времени, который сохранила Ева, и моментом, когда
запрос будет передан, есть некоторая задержка. Эта задержка может быть вызвана
обработкой запроса сетевым стеком на компьютерах Евы и Алисы или накладными
расходами на совершение системных вызовов к операционной системе.

Этот запрос принимается Алисой также с некоторой задержкой. После чего Алиса
обрабатывает его, начав в момент $T_2$ и закончив в момент $T_3$. Алиса
формирует ответ и отправляет его обратно Еве. Отправка и получение ответа так
же, как и запроса, сопровождаются задержками. Как только Ева получает ответ, она
запоминает текущее время $T_4$.

Еву интересует реальное время затраченное на шифрование, если обозначить его как
$X$, то $X = T_3 - T_2$.

Измеренное ей значение $Z$ представляет собой сумму искомой величины и шума
$Y = (T_2 - T_1) + (T_4 - T_3)$:

\begin{equation}
Z = X + Y = (T_3 - T_2) + (T_2 - T_1) + (T_4 - T_3) = T_4 - T_1
\end{equation} \label{eq:noise}

При атаке по времени на программу валидации пароля, атакующий обращается к
ней, поочерёдно передавая в качестве пароля все возможные строки из одного
символа. Та строка, которая совпадёт на один символ с паролем, потребует от
проверяющей программы выполнить на одну операцию сравнения больше, чем остальные
строки. Благодаря этому, на её проверку должно уйти больше времени. В качестве
догадки о том, каким был первый символ строки, атакующий примет ту строку,
обработка которой длилась дольше остальных. После чего, он повторит описанную
процедуру для того, чтобы узнать второй символ строки и все следующие за ним.

Так как доступная для измерения атакующим задержка ($Z$ в уравнении
\ref{eq:noise}) содержит шум, ему потребуется повторить каждое измерение
несколько раз.

Допустим, что атакующий уже сумел получить $n$ первых символов пароля. После
этого он снял по $m$ измерений времени обработки строк, полученных добавлением
к известным ему $n$ символам всех возможных вариантов следующего символа. Если
обозначить как $Z_i = \{ z_i^{(1)}, z_i^{(2)} ... z_i^{(m)} \}$ множество
измерений времени обработки строки, полученной добавлением к известным $n$
символам символа $s_i$, то задачей атакующего будет ответ на вопрос о том,
для какого $i$ мат. ожидание распределения, из которого были получены $Z_i$
наибольшее.

Что за бред? Может быть просто накинуть текст про линейную регрессию?

\subsection{Программа валидации пароля}

В этой главе описана разработка модели программы валидации пароля, которая будет
использована для оценки того, насколько точной может быть атака по времени на
такую программу.

Было решено реализовать модель программы валидации пароля на языке Си, так
как он позволяет очень точно контроллировать работу программы на низком
уровне, не требуя в большинстве случаев прибегать к использованию языка
ассемблера. В силу того, что язык Си компилируется в машинный код и не требует
для выполнения никакой виртуальной машины, написанные на нём программы
существенно производительнее программ, написанных на других популярных языках
программирования, таких как Lisp, Haskell, Perl или Python.

Реальная программа валидации пароля принимает от пользователя на вход строку,
которую она сравнивает с секретной строкой, хранящейся в недоступном для
пользователя месте. Взаимодействие с пользователем может происходить через
TCP, UDP или UNIX сокет, через терминал или через графический интерфейс.
Пароль, с которым сравнивается пользовательский ввод, может храниться в файле,
доступ к которому имеет только программа валидации пароля или на удалённом
сервере. Несмотря на существование более надёжных чем пароль методов авторзации
(публичные ключи, биометрические данные и др.), он по прежнему используется
многими программами. В реальности такие решения обычно хранят хеш-сумму пароля и
при помощи неё валидируют предоставленный пользователем пароль, но в данной работе
будет рассмотрен лишь вариант, когда пароль хранится в открытом виде.

Модель программы валидации пароля не имеет графического интерфейса и запускается
из командной строки, принимая в качестве единственного аргумента строку, которую
она сравнивает со статической константной строкой-паролем, которая хранится в
её памяти. Было решено сохранить строку-пароль статически в исполняемом файле
программы валидации пароля для уменьшения накладных расходов, которые возникли
бы, если бы программа была вынуждена читать эту строку из внешнего источника,
такого как файл, терминал или сокет. С той же целью в качестве способа ввода
пароля пользователем был выбран аргумент командной строки. Так как данная модель
представляет упрощённый вариант программы валидации пароля, в случае атаки на
реальную программу валидации пароля, шум, присутствующий в измерениях атакующего
будет сильнее и эффективность атаки ухудшится. Учитывая сказанное выше,
оценки эффективности атаки по времени, полученные на разработанной в данной
работе модели, могут рассматриваться как верхние оценки для эффективности атаки
на реальную прогамму.

При такой модели, атакующий имеет возможность многократно запускать
программу-модель, передавая ей в качестве аргумента выбранные им строки, и
измеряя время выполнения её выполнения. Общепринятым методом запуска программы
и ожидания её завершения в Linux является последовательность системных вызовов
\texttt{vfork}, \texttt{execve}, \texttt{wait} \cite{kerrisk}. При этом
атакующий не способен измерять задежки между событиями соседнего процесса, в
котором выполняется модель уязвимой программы. Ему доступна лишь задержка между
моментом, когда он создал новый процесс при помощи \texttt{vfork}, и моментом,
когда он дождался его завершения при помощи \texttt{wait}.

Для более точного исследования характиристик задержки, которая уходит на
сравнение строк, было принято решение добавить в программу валидации пароля
возможность измерения времени, которое ушло непосредственно на вызов функции
сравнения строк. С той же целью была добавлена возможность совершить несколько
операций сравнения одних и тех же строк за один запуск программы валидации
пароля.

\clearpage
