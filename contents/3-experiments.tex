\section{Эксперимент} \label{sec:experiment}

\subsection{Используемые инструменты}

Для исследований того, насколько велик шум, который влияет на измеряемое атакующим значение,
описанное в уравнении \ref{eq:noise}, была написана программа \nameref{app:vuln}, которая сравнивает
передаваемую ей в качестве аргумента строку с внутренней строкой, состоящей из большого числа
символов \texttt{'a'}. Программа повторяет вызов функции сравнения в цикле заданное
пользователем число раз. Также эта программа измеряет время, которое было потрачено ею
на выполнение всего цикла сравнений и сообщает его пользователю. Это время будет являться
реальным времение обработки запроса, которо было обозначено как $X$ в уравнении \ref{eq:noise}.

На листинге \ref{src:vulnsnip} показана основная часть программы \nameref{app:vuln}:

\begin{lstlisting}[caption=Фрагмент программы \texttt{vulnerable.c}, label=src:vulnsnip]
int (*my_strcmp)(const char *s1, const char *s2) = strcmp;

char reference[] = "aaa...";

int main(int argc, char **argv)
{
	uint64_t begin, end;

	/* ... */

	begin = timestamp();
	for (int i = 0; i < n; ++i)
		my_strcmp(argv[1], reference);
	end = timestamp();

	printf("%lld\n", end - begin);
}
\end{lstlisting}

Для сравнения строк используется библиотечная функция \texttt{strcmp}. Вызовы к ней совершаются
через глобальный указатель \texttt{my\_strcmp}. Это было сделано для того, чтобы предотвратить оптимизации
компилятором вызовов к библиотечной функции \texttt{strcmp}, которые тот мог произвести так как программа
была собрана с флагом \texttt{-O3} для получения наиболее оптимального кода.

Время измерялось при помощи функции \texttt{timestamp}, представленной на листинге
\ref{src:timestamp}.

\begin{lstlisting}[caption=Функция \texttt{timestamp}, label=src:timestamp]
static inline uint64_t timestamp(void)
{
	uint32_t bottom;
	uint32_t top;
	asm volatile (
			"CPUID\n\t"
			"RDTSC\n\t"
			"mov %%edx, %0\n\t"
			"mov %%eax, %1\n\t": "=r" (top), "=r" (bottom)
#if __x86_64__
			:: "%rax", "%rbx", "%rcx", "%rdx");
#elif __i386__
			:: "%eax", "%ebx", "%ecx", "%edx");
#endif
	return (((uint64_t) top) << 32) | bottom;
}
\end{lstlisting}

Эта функция получает текущее время, обращаясь к счётчику тактов процессора при
помощи ассемблерной инструкции \texttt{rdtsc}, доступной на процессорах Intel x86.
Этот способ рекомендуется разработчиками Intel \cite{rdtsc} как наиболее точный для измерения
времени. Полученное при помощи этой инструкции значение представляет собой число
число тактов, прошедших с момента старта процессора, и может быть переведено в
секунды делением на тактовую частоту процессора. Так же, эта функция выполняет инструкцию
\texttt{cpuid} для того, чтобы предотвратить внеочердное выполнение
(англ. Out-of-order execution) процессором инструкций, которые следуют за \texttt{rdtsc}.

Для измерения времени, которое в соответствии c описанной в главе <<\nameref{sec:timing}>>
моделью, соответсвовало бы времени, которое способен измерить атакующий, была
была написана программа \nameref{app:timestamp}, эта программа вызывает программу
\nameref{app:vuln} и дожидается её завершения при помощи последовательности системных
вызовов \texttt{fork}, \texttt{execve} и \texttt{wait}. При этом, она передаёт
программе \nameref{app:vuln} указанные пользователем аргументы и измеряет время, которое
прошло между моментом, когда она создала новый процесс при помощи \texttt{fork},
и моментом, когда она узнала о его завершении через системный вызов \texttt{wait}.
Как и в программе \nameref{app:vuln}, время измеряется при помощи функции \texttt{timetamp},
представленной на листинге \ref{src:timestamp}.

Для снятия большого числа измерений времени программами \nameref{app:vuln} и
\nameref{app:timestamp}, был написал Perl-скрипт \nameref{app:collect}. Основная логика его
работы преставлена на листинге \ref{src:collectsnip};

\begin{lstlisting}[caption=Фрагмент скрипта \texttt{collect.pl}, label=src:collectsnip]
my ($cmd, $reps, $its, $maxlen) = @ARGV;

print "iterations,length,cycles\n";

for (my $i = 0; $i < $reps; ++$i) {
	print STDERR "\r         \r$i / $reps" if ($i \% 100 == 0);

	my $len = int(rand $maxlen);
	my $str = "a" x $len . "b" x ($maxlen - $len);
	my $cycles = `$cmd $str $its`;
	chomp($cycles);
	print "$its,$len,$cycles\n"
}
\end{lstlisting}

Этот скрипт измеряет время выполнения цикла вызовов \texttt{strcmp} либо при помощи
программы \nameref{app:vuln}, либо при помощи \nameref{app:timestamp}, указанное пользователем
число раз и выводит на поток стандартного вывода таблицу измерений в формате CSV.
Для каждого измерения скрипт генерирует строку, которая совпадает с в внутренней строкой 
\nameref{app:vuln} на некоторое количество символов, которое выбирается при помощи генератора
псевдослучайных чисел для каждого запуска.

\subsection{Снятие измерений}

Запуск описанных в предыдущей секции программ осуществлялся на персональном компьютере с двухъядерным
процессором AMD E-300 под управлением операционной системы Linux с версией ядра
4.10.13. Более подробная информация о системе представлена в приложениях
\nameref{app:lscpu} и \nameref{app:uname}.

Для того, чтобы уменьшить шум, создаваемый множеством пользовательских процессов
и драйверов, которые обычно запущены на системе, измерения проводились без запуска
системы инициализации \texttt{systemd}. Для этого, при загрузке ядра, ему был
передан параметр \texttt{init=/bin/sh}, благодаря чему первым процессом, который
будет запущен ядром, будет оболочка \texttt{sh}. Из этой оболочки производился
запуск скрипта \nameref{app:collect}, вывод которого перенаправлялся в файл.

Использованная модель процессора поддерживает автоматическое изменение своей частоты
работы "на лету". Для избежания возможного влияния этой функции на точность измерений,
она была выключена вручную при помощи утилиты \texttt{cpupower},
а частота работы процессора установлена в неизменяемое значение 780 МГц.

Было снято $10^6$ измерений времени рельаной обработки запроса, которая была обозначена в
уравнении~\ref{eq:noise} как $X$, и столько же измерений времени, получаемого атакующим,
которе было обозначено в уравнении~\ref{eq:noise} как $Z$. Это было сделано при помощи
команд, представленных на листинге~\ref{src:collcalls}.

\begin{lstlisting}[caption=Команды снятия измерений, label=src:collcalls]
$ ./collect.pl ./vulnerable 1000000 10 5 > int-to-5-init.csv
$ ./collect.pl './timestamp ./vulnerable' 1000000 10 5 > ext-to-5-init.csv
\end{lstlisting}

В результате выполнения команд из листинга~\ref{src:collcalls} были получены два файла
\texttt{int-to-5-init.csv} и \texttt{ext-to-5-init.csv}. Каждый из которых содержит CSV-таблицу
из трёх столбцов:

\begin{description}
\item [\texttt{iterations}] число итераций цикла, представленного на
  листинге~\ref{src:vulnsnip}, совершённых при каждом вызове программы \nameref{app:vuln}
\item [\texttt{cycles}] измеренное время в циклах процессора
\item [\texttt{length}] длина общего префикса переданной программе \nameref{app:vuln} строки и
  внутренней строки, которая хранится в самой программе
\end{description}

\subsection{Анализ измерений}

В качестве инструмента для анализа снятых измерений было решено выбрать язык программирования
R \cite{r}, так как это очень мощный инструмент для статистического анализа и на нём реализованы
все требуемые для данной работы статистические алгоритмы.

    \begin{figure}
        \centering
        \includegraphics[width=0.5\textwidth]{data/sca-playground.wiki/strcmp_Timing_Attack/attempt-2/plots/int-to-5-init-non-outliers.png}
        \includegraphics[width=0.5\textwidth]{data/sca-playground.wiki/strcmp_Timing_Attack/attempt-2/plots/ext-to-5-init.png}
        \caption{Q-Q plots}
    \end{figure}

    \begin{figure}
        \centering
        \includegraphics[width=0.9\textwidth]{data/sca-playground.wiki/strcmp_Timing_Attack/attempt-2/plots/int-to-5-init-non-outliers-density.png}
        \caption{Внутренние измерения}
    \end{figure}

    \begin{figure}
        \centering
        \includegraphics[width=0.9\textwidth]{data/sca-playground.wiki/strcmp_Timing_Attack/attempt-2/plots/ext-to-5-init-density.png}
        \caption{Внешние измерения}
    \end{figure}

  % Table created by stargazer v.5.2 by Marek Hlavac, Harvard University. E-mail: hlavac at fas.harvard.edu
  % Date and time: Tue, May 23, 2017 - 08:11:20 AM
  \begin{table}[!htbp] \centering 
    \caption{Точечные оценки среднеквадратичного отклонения} 
    \label{} 
  \begin{tabular}{@{\extracolsep{5pt}} ccc} 
  \\[-1.8ex]\hline 
  \hline \\[-1.8ex] 
   & length & cycles \\ 
  \hline \\[-1.8ex] 
  1 & $0$ & $51.764$ \\ 
  2 & $1$ & $49.222$ \\ 
  3 & $2$ & $50.634$ \\ 
  4 & $3$ & $50.772$ \\ 
  5 & $4$ & $52.566$ \\ 
  \hline \\[-1.8ex] 
  \end{tabular} 
  \end{table} 

% Table created by stargazer v.5.2 by Marek Hlavac, Harvard University. E-mail: hlavac at fas.harvard.edu
% Date and time: Tue, May 23, 2017 - 08:03:32 AM
\begin{table}[!htbp] \centering 
  \caption{Доверительные интервалы мат. ожидания} 
  \label{} 
\begin{tabular}{@{\extracolsep{5pt}} cccc} 
\\[-1.8ex]\hline 
\hline \\[-1.8ex] 
 & length & left & right \\ 
\hline \\[-1.8ex] 
1 & $0$ & $879.413$ & $879.867$ \\ 
2 & $1$ & $892.966$ & $893.398$ \\ 
3 & $2$ & $927.871$ & $928.315$ \\ 
4 & $3$ & $958.985$ & $959.430$ \\ 
5 & $4$ & $1,009.111$ & $1,009.571$ \\ 
\hline \\[-1.8ex] 
\end{tabular} 
\end{table} 

% Table created by stargazer v.5.2 by Marek Hlavac, Harvard University. E-mail: hlavac at fas.harvard.edu
% Date and time: Tue, May 23, 2017 - 09:01:52 AM
\begin{table}[!htbp] \centering 
  \caption{Линейная модель для внутренних измерений} 
  \label{} 
\begin{tabular}{@{\extracolsep{5pt}}lc} 
\\[-1.8ex]\hline 
\hline \\[-1.8ex] 
 & \multicolumn{1}{c}{\textit{Dependent variable:}} \\ 
\cline{2-2} 
\\[-1.8ex] & cycles \\ 
\hline \\[-1.8ex] 
 length & 32.556$^{***}$ (32.461, 32.650) \\ 
  Constant & 868.782$^{***}$ (868.551, 869.013) \\ 
 \hline \\[-1.8ex] 
Adjusted R$^{2}$ & 0.442 \\ 
Residual Std. Error & 51.739 (df = 999702) \\ 
F Statistic & 791,637.300$^{***}$ (df = 1; 999702) \\ 
\hline 
\hline
\textit{Note:}  & \multicolumn{1}{r}{$^{*}$p$<$0.1; $^{**}$p$<$0.05; $^{***}$p$<$0.01} \\ 
\end{tabular} 
\end{table} 

% Table created by stargazer v.5.2 by Marek Hlavac, Harvard University. E-mail: hlavac at fas.harvard.edu
% Date and time: Tue, May 23, 2017 - 08:29:22 AM
\begin{table}[!htbp] \centering 
  \caption{Точечные оценки среднеквадратичного отклонения} 
  \label{} 
\begin{tabular}{@{\extracolsep{5pt}} ccc} 
\\[-1.8ex]\hline 
\hline \\[-1.8ex] 
 & length & cycles \\ 
\hline \\[-1.8ex] 
1 & $0$ & $51,045.670$ \\ 
2 & $1$ & $51,055.780$ \\ 
3 & $2$ & $51,097.950$ \\ 
4 & $3$ & $51,228.100$ \\ 
5 & $4$ & $51,135.910$ \\ 
\hline \\[-1.8ex] 
\end{tabular} 
\end{table} 

% Table created by stargazer v.5.2 by Marek Hlavac, Harvard University. E-mail: hlavac at fas.harvard.edu
% Date and time: Tue, May 23, 2017 - 09:05:06 AM
\begin{table}[!htbp] \centering 
  \caption{Линейная модель для внешних измерений} 
  \label{} 
\begin{tabular}{@{\extracolsep{5pt}}lc} 
\\[-1.8ex]\hline 
\hline \\[-1.8ex] 
 & \multicolumn{1}{c}{\textit{Dependent variable:}} \\ 
\cline{2-2} 
\\[-1.8ex] & cycles \\ 
\hline \\[-1.8ex] 
 length & 78.012$^{**}$ ($-$15.081, 171.105) \\ 
  Constant & 1.2e+6$^{***}$ (1,222,255, 1,222,711) \\ 
 \hline \\[-1.8ex] 
Adjusted R$^{2}$ & 0.00000 \\ 
Residual Std. Error & 51,112.740 (df = 999998) \\ 
F Statistic & 4.659$^{**}$ (df = 1; 999998) \\ 
\hline 
\hline \\[-1.8ex] 
\textit{Note:}  & \multicolumn{1}{r}{$^{*}$p$<$0.1; $^{**}$p$<$0.05; $^{***}$p$<$0.01} \\ 
\end{tabular} 
\end{table} 

\clearpage
